\doxysection{src/threads/user\+\_\+thread.c File Reference}
\hypertarget{user__thread_8c}{}\label{user__thread_8c}\index{src/threads/user\_thread.c@{src/threads/user\_thread.c}}
{\ttfamily \#include "{}../../include/threads/user\+\_\+thread.\+h"{}}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include "{}../../include/variables/globals.\+h"{}}\newline
{\ttfamily \#include "{}../../include/variables/structures.\+h"{}}\newline
{\ttfamily \#include "{}../../include/variables/macros.\+h"{}}\newline
{\ttfamily \#include "{}../../include/utils/pte\+\_\+utils.\+h"{}}\newline
{\ttfamily \#include "{}../../include/utils/page\+\_\+utils.\+h"{}}\newline
{\ttfamily \#include "{}../../include/disk/disk.\+h"{}}\newline
{\ttfamily \#include "{}../../include/utils/thread\+\_\+utils.\+h"{}}\newline
{\ttfamily \#include "{}initialization/init.\+h"{}}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
VOID \mbox{\hyperlink{user__thread_8c_a448eb2bbcbf9ade5e09d3af9b2bb0ea3}{add\+Page\+To\+Free\+List}} (\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*}page, \mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Info)
\begin{DoxyCompactList}\small\item\em Adds a page to any available freelist. \end{DoxyCompactList}\item 
VOID \mbox{\hyperlink{user__thread_8c_a6730003fb29092de5ffafa988d59deac}{batch\+Victims\+From\+Stand\+By\+List}} (\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Info)
\begin{DoxyCompactList}\small\item\em Removes a batch of victims from the standby list and puts them on the free list. \end{DoxyCompactList}\item 
PVOID \mbox{\hyperlink{user__thread_8c_a6601998c57f4c3d80891bfcab071441d}{get\+Thread\+Mapping}} (\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Context)
\begin{DoxyCompactList}\small\item\em A function that gets the current transfer virtual address that a thread needs. \end{DoxyCompactList}\item 
VOID \mbox{\hyperlink{user__thread_8c_a9a16d9a9c52782f31f8cbe5ee8fd14e9}{free\+Thread\+Mapping}} (\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Context)
\begin{DoxyCompactList}\small\item\em Unmaps the thread\textquotesingle{}s transfer virtual address space if it has all mapped. Batching it in this way saves a lot of time spent mapping and flushing. \end{DoxyCompactList}\item 
BOOL \mbox{\hyperlink{user__thread_8c_a15daaf165c91aa6784d5c54ea0acef75}{page\+Fault}} (PULONG\+\_\+\+PTR arbitrary\+\_\+va, LPVOID thread\+Context)
\begin{DoxyCompactList}\small\item\em This function is the core of the program. It will culminate in the mapping of a physical page to the passed in virtual address. \end{DoxyCompactList}\item 
BOOL \mbox{\hyperlink{user__thread_8c_a054a809045b98743dd633e71b528a419}{is\+Rescue}} (\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}current\+PTE)
\item 
BOOL \mbox{\hyperlink{user__thread_8c_a77064328a04d35d501edae073abba4e7}{rescue\+\_\+page}} (ULONG64 arbitrary\+\_\+va, \mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}current\+PTE, \mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Info)
\begin{DoxyCompactList}\small\item\em This function will rescue a page table entry that has been unmapped by the trimming thread, but the contents of the virtual page are still on the physical page. If the page corresponding to the virtual address is on the modified list, this function just simply removes it from the middle. If the page is on the standby list, this function removes it from the middle of the list and sets the corresponding disk space free. Lastly, If the page is not on any list, but in the process of being written out, just mark it as no longer being written out. The writer will see this and free the corresponding disk space. \end{DoxyCompactList}\item 
BOOL \mbox{\hyperlink{user__thread_8c_a09f6bd7a22266dc562f57a1c51d67320}{map\+Page}} (ULONG64 arbitrary\+\_\+va, \mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}current\+PTE, LPVOID thread\+Context, PCRITICAL\+\_\+\+SECTION current\+Page\+Table\+Lock)
\begin{DoxyCompactList}\small\item\em This function handles the first time a virtual address is accessed, and if a virtual address contents are on disk. First this thread will attempt to map from the free list; then it will try to map from standby. If none of those succeed it will wake up the trimmer and wait to redo the fault. If this thread notices that usable pages are getting low, it will wake up the trimmer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{user__thread_8c_a39091ec036a9c3ade72645232a6c655b}{map\+Page\+From\+Free\+List}} (\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}current\+PTE, \mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Info)
\begin{DoxyCompactList}\small\item\em This function tries to get a physical page of a free list. It will also detect if the number of free pages is running low, and take some from the standby list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{user__thread_8c_abe86a2d11f81fe2a1b903588bffd3972}{map\+Page\+From\+Stand\+By\+List}} (\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}current\+PTE, \mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Info)
\begin{DoxyCompactList}\small\item\em This function attempts to take a page from the standby list. If there is a page to take, this function will update the page\textquotesingle{}s pagetable entry to reflect that it is no longer on standby, but on disk. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{user__thread_8c_adf110e8fee1dab537a5b4a22909843d5}{get\+Victim\+From\+Stand\+By\+List}} (\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Info)
\begin{DoxyCompactList}\small\item\em This function pops a page off the standby list and updates its pte. Important note, it updates the page table entry of the page without holding a page table lock. It can do this because the page table entry\textquotesingle{}s corresponding page lock protects it from being rescued at the same. However, this means that in the rescue or other functions relating to standby pages, the page table entry could be changing. \end{DoxyCompactList}\item 
VOID \mbox{\hyperlink{user__thread_8c_aa4d5559bed59f8700f4e332ffedd6064}{modified\+\_\+read}} (\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}current\+PTE, ULONG64 frame\+Number, \mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Context)
\begin{DoxyCompactList}\small\item\em This function reads in the contents of a disk page onto a physical page. It uses an interim transfer virtual address to complete this task. Only after the entire transfer space is used, will this function unmap the pages from the transfer virtual address. By having limited unmap calls, a lot of time spent flushing and unmapping is saved. \end{DoxyCompactList}\item 
BOOL \mbox{\hyperlink{user__thread_8c_af2a00908cb7f283fa07f7372f2533d6d}{zero\+One\+Page}} (\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*}page, \mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Context)
\begin{DoxyCompactList}\small\item\em This function zeroes a physical page. It uses an interim transfer virtual address to complete this task. Only after the entire transfer space is used, will this function unmap the pages from the transfer virtual address. By having limited unmap calls, a lot of time spent flushing and unmapping is saved. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{user__thread_8c_aaac03443ad63f63ed80d86cbfcc6bec0}{get\+Page\+From\+Free\+List}} (\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Context)
\begin{DoxyCompactList}\small\item\em This function gets a page off of one of the free lists. It returns with the page locked. \end{DoxyCompactList}\end{DoxyCompactItemize}


\label{doc-func-members}
\Hypertarget{user__thread_8c_doc-func-members}
\doxysubsection{Function Documentation}
\Hypertarget{user__thread_8c_a448eb2bbcbf9ade5e09d3af9b2bb0ea3}\index{user\_thread.c@{user\_thread.c}!addPageToFreeList@{addPageToFreeList}}
\index{addPageToFreeList@{addPageToFreeList}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{addPageToFreeList()}{addPageToFreeList()}}
{\footnotesize\ttfamily \label{user__thread_8c_a448eb2bbcbf9ade5e09d3af9b2bb0ea3} 
VOID add\+Page\+To\+Free\+List (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*}}]{page}{, }\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Info}{}\end{DoxyParamCaption})}



Adds a page to any available freelist. 


\begin{DoxyParams}{Parameters}
{\em page} & The page you are inserting into the list \\
\hline
{\em thread\+Info} & The thread info of a caller. It is mainly used for debug functions\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The page must be locked. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The caller must release the page lock. 
\end{DoxyPostcond}
\Hypertarget{user__thread_8c_a6730003fb29092de5ffafa988d59deac}\index{user\_thread.c@{user\_thread.c}!batchVictimsFromStandByList@{batchVictimsFromStandByList}}
\index{batchVictimsFromStandByList@{batchVictimsFromStandByList}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{batchVictimsFromStandByList()}{batchVictimsFromStandByList()}}
{\footnotesize\ttfamily \label{user__thread_8c_a6730003fb29092de5ffafa988d59deac} 
VOID batch\+Victims\+From\+Stand\+By\+List (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Info}{}\end{DoxyParamCaption})}



Removes a batch of victims from the standby list and puts them on the free list. 


\begin{DoxyParams}{Parameters}
{\em thread\+Info} & The thread info of a caller. It is mainly used for debug functions. \\
\hline
\end{DoxyParams}
\Hypertarget{user__thread_8c_a9a16d9a9c52782f31f8cbe5ee8fd14e9}\index{user\_thread.c@{user\_thread.c}!freeThreadMapping@{freeThreadMapping}}
\index{freeThreadMapping@{freeThreadMapping}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{freeThreadMapping()}{freeThreadMapping()}}
{\footnotesize\ttfamily \label{user__thread_8c_a9a16d9a9c52782f31f8cbe5ee8fd14e9} 
VOID free\+Thread\+Mapping (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Context}{}\end{DoxyParamCaption})}



Unmaps the thread\textquotesingle{}s transfer virtual address space if it has all mapped. Batching it in this way saves a lot of time spent mapping and flushing. 


\begin{DoxyParams}{Parameters}
{\em thread\+Context} & The thread info of the caller. It is used to index into the correct transfer virtual address space. \\
\hline
\end{DoxyParams}
\Hypertarget{user__thread_8c_aaac03443ad63f63ed80d86cbfcc6bec0}\index{user\_thread.c@{user\_thread.c}!getPageFromFreeList@{getPageFromFreeList}}
\index{getPageFromFreeList@{getPageFromFreeList}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{getPageFromFreeList()}{getPageFromFreeList()}}
{\footnotesize\ttfamily \label{user__thread_8c_aaac03443ad63f63ed80d86cbfcc6bec0} 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} get\+Page\+From\+Free\+List (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Context}{}\end{DoxyParamCaption})}



This function gets a page off of one of the free lists. It returns with the page locked. 


\begin{DoxyParams}{Parameters}
{\em thread\+Context} & The thread info of the caller. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a free page. 
\end{DoxyReturn}
\begin{DoxyPostcond}{Postcondition}
The caller must release the page lock of the returned page. 
\end{DoxyPostcond}
\Hypertarget{user__thread_8c_a6601998c57f4c3d80891bfcab071441d}\index{user\_thread.c@{user\_thread.c}!getThreadMapping@{getThreadMapping}}
\index{getThreadMapping@{getThreadMapping}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{getThreadMapping()}{getThreadMapping()}}
{\footnotesize\ttfamily \label{user__thread_8c_a6601998c57f4c3d80891bfcab071441d} 
PVOID get\+Thread\+Mapping (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Context}{}\end{DoxyParamCaption})}



A function that gets the current transfer virtual address that a thread needs. 


\begin{DoxyParams}{Parameters}
{\em thread\+Context} & The thread info of the caller. It is used to update the per thread index into its transfer virtual address space. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to a page of unmapped transfer virtual address space. 
\end{DoxyReturn}
\Hypertarget{user__thread_8c_adf110e8fee1dab537a5b4a22909843d5}\index{user\_thread.c@{user\_thread.c}!getVictimFromStandByList@{getVictimFromStandByList}}
\index{getVictimFromStandByList@{getVictimFromStandByList}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{getVictimFromStandByList()}{getVictimFromStandByList()}}
{\footnotesize\ttfamily \label{user__thread_8c_adf110e8fee1dab537a5b4a22909843d5} 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} get\+Victim\+From\+Stand\+By\+List (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Info}{}\end{DoxyParamCaption})}



This function pops a page off the standby list and updates its pte. Important note, it updates the page table entry of the page without holding a page table lock. It can do this because the page table entry\textquotesingle{}s corresponding page lock protects it from being rescued at the same. However, this means that in the rescue or other functions relating to standby pages, the page table entry could be changing. 


\begin{DoxyParams}{Parameters}
{\em thread\+Info} & The thread info of the caller. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return a page from the standby list. If the list is empty return NULL 
\end{DoxyReturn}
\Hypertarget{user__thread_8c_a054a809045b98743dd633e71b528a419}\index{user\_thread.c@{user\_thread.c}!isRescue@{isRescue}}
\index{isRescue@{isRescue}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{isRescue()}{isRescue()}}
{\footnotesize\ttfamily \label{user__thread_8c_a054a809045b98743dd633e71b528a419} 
BOOL is\+Rescue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}}]{current\+PTE}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em current\+PTE} & The page table entry of the virtual address that was faulted on. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
It returns true if the current\+PTE is signaled as transition.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The page table entry must be locked. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The caller must release the lock of the page table entry. 
\end{DoxyPostcond}
\Hypertarget{user__thread_8c_a09f6bd7a22266dc562f57a1c51d67320}\index{user\_thread.c@{user\_thread.c}!mapPage@{mapPage}}
\index{mapPage@{mapPage}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{mapPage()}{mapPage()}}
{\footnotesize\ttfamily \label{user__thread_8c_a09f6bd7a22266dc562f57a1c51d67320} 
BOOL map\+Page (\begin{DoxyParamCaption}\item[{ULONG64}]{arbitrary\+\_\+va}{, }\item[{\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}}]{current\+PTE}{, }\item[{LPVOID}]{thread\+Context}{, }\item[{PCRITICAL\+\_\+\+SECTION}]{current\+Page\+Table\+Lock}{}\end{DoxyParamCaption})}



This function handles the first time a virtual address is accessed, and if a virtual address contents are on disk. First this thread will attempt to map from the free list; then it will try to map from standby. If none of those succeed it will wake up the trimmer and wait to redo the fault. If this thread notices that usable pages are getting low, it will wake up the trimmer. 


\begin{DoxyParams}{Parameters}
{\em arbitrary\+\_\+va} & The virtual address being accessed. \\
\hline
{\em current\+PTE} & The page table entry of the virtual address being accessed. \\
\hline
{\em thread\+Context} & The thread info of the faulting thread. \\
\hline
{\em current\+Page\+Table\+Lock} & The lock corresponding to the page table entry \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if we need to redo the fault, false otherwise. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The page table entry must be locked on entry to this function. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The caller must unlock the page table entry. 
\end{DoxyPostcond}
\Hypertarget{user__thread_8c_a39091ec036a9c3ade72645232a6c655b}\index{user\_thread.c@{user\_thread.c}!mapPageFromFreeList@{mapPageFromFreeList}}
\index{mapPageFromFreeList@{mapPageFromFreeList}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{mapPageFromFreeList()}{mapPageFromFreeList()}}
{\footnotesize\ttfamily \label{user__thread_8c_a39091ec036a9c3ade72645232a6c655b} 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} map\+Page\+From\+Free\+List (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}}]{current\+PTE}{, }\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Info}{}\end{DoxyParamCaption})}



This function tries to get a physical page of a free list. It will also detect if the number of free pages is running low, and take some from the standby list. 


\begin{DoxyParams}{Parameters}
{\em current\+PTE} & The page table entry of the virtual address that is being faulted on \\
\hline
{\em thread\+Info} & The info about the calling thread. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a page from a freelist 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em Returns} & null if the list is empty \\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
The page table entry must be locked on entry to this function. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The caller must unlock the page table entry. 
\end{DoxyPostcond}
\Hypertarget{user__thread_8c_abe86a2d11f81fe2a1b903588bffd3972}\index{user\_thread.c@{user\_thread.c}!mapPageFromStandByList@{mapPageFromStandByList}}
\index{mapPageFromStandByList@{mapPageFromStandByList}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{mapPageFromStandByList()}{mapPageFromStandByList()}}
{\footnotesize\ttfamily \label{user__thread_8c_abe86a2d11f81fe2a1b903588bffd3972} 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} map\+Page\+From\+Stand\+By\+List (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}}]{current\+PTE}{, }\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Info}{}\end{DoxyParamCaption})}



This function attempts to take a page from the standby list. If there is a page to take, this function will update the page\textquotesingle{}s pagetable entry to reflect that it is no longer on standby, but on disk. 


\begin{DoxyParams}{Parameters}
{\em current\+PTE} & The page table entry of the virtual address that is being faulted on \\
\hline
{\em thread\+Info} & The info of the calling thread \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a page from a freelist 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em Returns} & null if the list is empty \\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
The page table entry must be locked on entry to this function. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The caller must unlock the page table entry 
\end{DoxyPostcond}
\Hypertarget{user__thread_8c_aa4d5559bed59f8700f4e332ffedd6064}\index{user\_thread.c@{user\_thread.c}!modified\_read@{modified\_read}}
\index{modified\_read@{modified\_read}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{modified\_read()}{modified\_read()}}
{\footnotesize\ttfamily \label{user__thread_8c_aa4d5559bed59f8700f4e332ffedd6064} 
VOID modified\+\_\+read (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}}]{current\+PTE}{, }\item[{ULONG64}]{frame\+Number}{, }\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Context}{}\end{DoxyParamCaption})}



This function reads in the contents of a disk page onto a physical page. It uses an interim transfer virtual address to complete this task. Only after the entire transfer space is used, will this function unmap the pages from the transfer virtual address. By having limited unmap calls, a lot of time spent flushing and unmapping is saved. 


\begin{DoxyParams}{Parameters}
{\em current\+PTE} & The page table entry that contains the disk page we want to read from. \\
\hline
{\em frame\+Number} & The frame to read into. \\
\hline
{\em thread\+Context} & The caller\textquotesingle{}s thread info. It is used to determine which transfer virtual page to use \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The page table entry must be locked on entry to this function. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The caller must unlock the page table entry 
\end{DoxyPostcond}
\Hypertarget{user__thread_8c_a15daaf165c91aa6784d5c54ea0acef75}\index{user\_thread.c@{user\_thread.c}!pageFault@{pageFault}}
\index{pageFault@{pageFault}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{pageFault()}{pageFault()}}
{\footnotesize\ttfamily \label{user__thread_8c_a15daaf165c91aa6784d5c54ea0acef75} 
BOOL page\+Fault (\begin{DoxyParamCaption}\item[{PULONG\+\_\+\+PTR}]{arbitrary\+\_\+va}{, }\item[{LPVOID}]{thread\+Context}{}\end{DoxyParamCaption})}



This function is the core of the program. It will culminate in the mapping of a physical page to the passed in virtual address. 


\begin{DoxyParams}{Parameters}
{\em arbitrary\+\_\+va} & The virtual address that is being accessed and faulted on. \\
\hline
{\em thread\+Context} & The information about the faulting thread. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A boolean that determines whether we need to back up and redo the fault. 
\end{DoxyReturn}
\Hypertarget{user__thread_8c_a77064328a04d35d501edae073abba4e7}\index{user\_thread.c@{user\_thread.c}!rescue\_page@{rescue\_page}}
\index{rescue\_page@{rescue\_page}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{rescue\_page()}{rescue\_page()}}
{\footnotesize\ttfamily \label{user__thread_8c_a77064328a04d35d501edae073abba4e7} 
BOOL rescue\+\_\+page (\begin{DoxyParamCaption}\item[{ULONG64}]{arbitrary\+\_\+va}{, }\item[{\mbox{\hyperlink{structpte}{pte}} \texorpdfstring{$\ast$}{*}}]{current\+PTE}{, }\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Info}{}\end{DoxyParamCaption})}



This function will rescue a page table entry that has been unmapped by the trimming thread, but the contents of the virtual page are still on the physical page. If the page corresponding to the virtual address is on the modified list, this function just simply removes it from the middle. If the page is on the standby list, this function removes it from the middle of the list and sets the corresponding disk space free. Lastly, If the page is not on any list, but in the process of being written out, just mark it as no longer being written out. The writer will see this and free the corresponding disk space. 


\begin{DoxyParams}{Parameters}
{\em arbitrary\+\_\+va} & The virtual address that is faulted on. \\
\hline
{\em current\+PTE} & The page table entry corresponding with the virtual address. \\
\hline
{\em thread\+Info} & The info of the thread that is faulted on. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if we need to redo the fault, false otherwise. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The page table entry must be locked on entry to this function. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The caller must unlock the page table entry 
\end{DoxyPostcond}
\Hypertarget{user__thread_8c_af2a00908cb7f283fa07f7372f2533d6d}\index{user\_thread.c@{user\_thread.c}!zeroOnePage@{zeroOnePage}}
\index{zeroOnePage@{zeroOnePage}!user\_thread.c@{user\_thread.c}}
\doxysubsubsection{\texorpdfstring{zeroOnePage()}{zeroOnePage()}}
{\footnotesize\ttfamily \label{user__thread_8c_af2a00908cb7f283fa07f7372f2533d6d} 
BOOL zero\+One\+Page (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*}}]{page}{, }\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Context}{}\end{DoxyParamCaption})}



This function zeroes a physical page. It uses an interim transfer virtual address to complete this task. Only after the entire transfer space is used, will this function unmap the pages from the transfer virtual address. By having limited unmap calls, a lot of time spent flushing and unmapping is saved. 


\begin{DoxyParams}{Parameters}
{\em page} & The page to zero. \\
\hline
{\em thread\+Context} & The caller\textquotesingle{}s thread info. It is used to determine which transfer virtual page to use. \\
\hline
\end{DoxyParams}
