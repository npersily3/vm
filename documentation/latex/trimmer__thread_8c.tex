\doxysection{src/threads/trimmer\+\_\+thread.c File Reference}
\hypertarget{trimmer__thread_8c}{}\label{trimmer__thread_8c}\index{src/threads/trimmer\_thread.c@{src/threads/trimmer\_thread.c}}


This file containsa protocal for unmapping active pages and adding them to a modified list.  


{\ttfamily \#include "{}../../include/threads/trimmer\+\_\+thread.\+h"{}}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include "{}../../include/variables/structures.\+h"{}}\newline
{\ttfamily \#include "{}../../include/variables/globals.\+h"{}}\newline
{\ttfamily \#include "{}../../include/variables/macros.\+h"{}}\newline
{\ttfamily \#include "{}../../include/utils/pte\+\_\+utils.\+h"{}}\newline
{\ttfamily \#include "{}../../include/utils/page\+\_\+utils.\+h"{}}\newline
{\ttfamily \#include "{}../../include/utils/thread\+\_\+utils.\+h"{}}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
DWORD \mbox{\hyperlink{trimmer__thread_8c_ad435722c9283c37221db5ee47f172da9}{page\+\_\+trimmer}} (LPVOID info)
\begin{DoxyCompactList}\small\item\em This is the function that deals with unmapping pages. It will pop a page off the active list and add it to the modified list. It will batch unmap if the consecutive pages are in the same page table entry region. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{trimmer__thread_8c_a66447264f92e1fef2cf4a1496ac42760}{get\+Active\+Page}} (\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Context)
\begin{DoxyCompactList}\small\item\em This functions pops a page off the active list and returns it unlocked. \end{DoxyCompactList}\item 
VOID \mbox{\hyperlink{trimmer__thread_8c_aefb918ee98100baec9ed6e9bf1b8e58b}{unmap\+Batch}} (PULONG64 virtual\+Addresses, ULONG64 batch\+Size)
\begin{DoxyCompactList}\small\item\em Simple wrapper for a Map\+User\+Physical\+Pages\+Scatter call. \end{DoxyCompactList}\item 
VOID \mbox{\hyperlink{trimmer__thread_8c_a9f5290d354fd250aaa561208846ed337}{add\+Batch\+To\+Modified\+List}} (\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}pages, ULONG64 batch\+Size, \mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} thread\+Context)
\begin{DoxyCompactList}\small\item\em This function adds a batch of pages to the modified list. \end{DoxyCompactList}\item 
BOOL \mbox{\hyperlink{trimmer__thread_8c_a7ab4b49f6892ee10915cb0ea079b3529}{is\+Next\+Page\+In\+Same\+Region}} (\mbox{\hyperlink{struct_p_t_e___r_e_g_i_o_n}{PTE\+\_\+\+REGION}} \texorpdfstring{$\ast$}{*}region, \mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}} info)
\begin{DoxyCompactList}\small\item\em This function peeks into the head of the active list and sees if the next page is in the same pte region. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This file containsa protocal for unmapping active pages and adding them to a modified list. 

\begin{DoxyAuthor}{Author}
Noah Persily 
\end{DoxyAuthor}


\label{doc-func-members}
\Hypertarget{trimmer__thread_8c_doc-func-members}
\doxysubsection{Function Documentation}
\Hypertarget{trimmer__thread_8c_a9f5290d354fd250aaa561208846ed337}\index{trimmer\_thread.c@{trimmer\_thread.c}!addBatchToModifiedList@{addBatchToModifiedList}}
\index{addBatchToModifiedList@{addBatchToModifiedList}!trimmer\_thread.c@{trimmer\_thread.c}}
\doxysubsubsection{\texorpdfstring{addBatchToModifiedList()}{addBatchToModifiedList()}}
{\footnotesize\ttfamily \label{trimmer__thread_8c_a9f5290d354fd250aaa561208846ed337} 
VOID add\+Batch\+To\+Modified\+List (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{pages}{, }\item[{ULONG64}]{batch\+Size}{, }\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Context}{}\end{DoxyParamCaption})}



This function adds a batch of pages to the modified list. 


\begin{DoxyParams}{Parameters}
{\em pages} & An array of pointers to pages. \\
\hline
{\em batch\+Size} & The size of the array. \\
\hline
{\em thread\+Context} & The thread info of the caller \\
\hline
\end{DoxyParams}
\Hypertarget{trimmer__thread_8c_a66447264f92e1fef2cf4a1496ac42760}\index{trimmer\_thread.c@{trimmer\_thread.c}!getActivePage@{getActivePage}}
\index{getActivePage@{getActivePage}!trimmer\_thread.c@{trimmer\_thread.c}}
\doxysubsubsection{\texorpdfstring{getActivePage()}{getActivePage()}}
{\footnotesize\ttfamily \label{trimmer__thread_8c_a66447264f92e1fef2cf4a1496ac42760} 
\mbox{\hyperlink{structpfn}{pfn}} \texorpdfstring{$\ast$}{*} get\+Active\+Page (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{thread\+Context}{}\end{DoxyParamCaption})}



This functions pops a page off the active list and returns it unlocked. 


\begin{DoxyParams}{Parameters}
{\em thread\+Context} & The thread info of the caller. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns an active page. If the list is empty, it returns null. 
\end{DoxyReturn}
\Hypertarget{trimmer__thread_8c_a7ab4b49f6892ee10915cb0ea079b3529}\index{trimmer\_thread.c@{trimmer\_thread.c}!isNextPageInSameRegion@{isNextPageInSameRegion}}
\index{isNextPageInSameRegion@{isNextPageInSameRegion}!trimmer\_thread.c@{trimmer\_thread.c}}
\doxysubsubsection{\texorpdfstring{isNextPageInSameRegion()}{isNextPageInSameRegion()}}
{\footnotesize\ttfamily \label{trimmer__thread_8c_a7ab4b49f6892ee10915cb0ea079b3529} 
BOOL is\+Next\+Page\+In\+Same\+Region (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_p_t_e___r_e_g_i_o_n}{PTE\+\_\+\+REGION}} \texorpdfstring{$\ast$}{*}}]{region}{, }\item[{\mbox{\hyperlink{structures_8h_a0d2bf865b114b5aa46dd6f5558f60df4}{PTHREAD\+\_\+\+INFO}}}]{info}{}\end{DoxyParamCaption})}



This function peeks into the head of the active list and sees if the next page is in the same pte region. 


\begin{DoxyParams}{Parameters}
{\em region} & The page table region struct of the batch that is currently being trimmed. \\
\hline
{\em info} & The info of the caller. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if the next page\textquotesingle{}s corresponding page table entry is in the region passed in. 
\end{DoxyReturn}
\Hypertarget{trimmer__thread_8c_ad435722c9283c37221db5ee47f172da9}\index{trimmer\_thread.c@{trimmer\_thread.c}!page\_trimmer@{page\_trimmer}}
\index{page\_trimmer@{page\_trimmer}!trimmer\_thread.c@{trimmer\_thread.c}}
\doxysubsubsection{\texorpdfstring{page\_trimmer()}{page\_trimmer()}}
{\footnotesize\ttfamily \label{trimmer__thread_8c_ad435722c9283c37221db5ee47f172da9} 
DWORD page\+\_\+trimmer (\begin{DoxyParamCaption}\item[{LPVOID}]{info}{}\end{DoxyParamCaption})}



This is the function that deals with unmapping pages. It will pop a page off the active list and add it to the modified list. It will batch unmap if the consecutive pages are in the same page table entry region. 


\begin{DoxyParams}{Parameters}
{\em info} & A pointer to a thread info struct. Passed in during the function Create\+Thread \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & If the program succeeds \\
\hline
\end{DoxyRetVals}
\Hypertarget{trimmer__thread_8c_aefb918ee98100baec9ed6e9bf1b8e58b}\index{trimmer\_thread.c@{trimmer\_thread.c}!unmapBatch@{unmapBatch}}
\index{unmapBatch@{unmapBatch}!trimmer\_thread.c@{trimmer\_thread.c}}
\doxysubsubsection{\texorpdfstring{unmapBatch()}{unmapBatch()}}
{\footnotesize\ttfamily \label{trimmer__thread_8c_aefb918ee98100baec9ed6e9bf1b8e58b} 
VOID unmap\+Batch (\begin{DoxyParamCaption}\item[{PULONG64}]{virtual\+Addresses}{, }\item[{ULONG64}]{batch\+Size}{}\end{DoxyParamCaption})}



Simple wrapper for a Map\+User\+Physical\+Pages\+Scatter call. 


\begin{DoxyParams}{Parameters}
{\em virtual\+Addresses} & An array of virtual addresses to unmap. \\
\hline
{\em batch\+Size} & The size of the array. \\
\hline
\end{DoxyParams}
