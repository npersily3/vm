<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Virtual Memory Manager: src/threads/user_thread.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Virtual Memory Manager
   </div>
   <div id="projectbrief">A implementation of a multithread page fault handler</div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('user__thread_8c.html','',''); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
</script>
<div id="main-nav"></div>
<div id="container"><div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">user_thread.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="user__thread_8h_source.html">../../include/threads/user_thread.h</a>&quot;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="globals_8h_source.html">../../include/variables/globals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="structures_8h_source.html">../../include/variables/structures.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">../../include/variables/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pte__utils_8h_source.html">../../include/utils/pte_utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page__utils_8h_source.html">../../include/utils/page_utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="disk_8h_source.html">../../include/disk/disk.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="thread__utils_8h_source.html">../../include/utils/thread_utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="init_8h_source.html">initialization/init.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad208b74b4a578d8eb271b1d9ed34d5c2" id="r_ad208b74b4a578d8eb271b1d9ed34d5c2"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad208b74b4a578d8eb271b1d9ed34d5c2">spinWhileWaiting</a> (VOID)</td></tr>
<tr class="memdesc:ad208b74b4a578d8eb271b1d9ed34d5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function spins while waiting so waits show up as time on a performance trace.  <br /></td></tr>
<tr class="memitem:a448eb2bbcbf9ade5e09d3af9b2bb0ea3" id="r_a448eb2bbcbf9ade5e09d3af9b2bb0ea3"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448eb2bbcbf9ade5e09d3af9b2bb0ea3">addPageToFreeList</a> (<a class="el" href="structpfn.html">pfn</a> *page, <a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadInfo)</td></tr>
<tr class="memdesc:a448eb2bbcbf9ade5e09d3af9b2bb0ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a page to any available freelist.  <br /></td></tr>
<tr class="memitem:a6730003fb29092de5ffafa988d59deac" id="r_a6730003fb29092de5ffafa988d59deac"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6730003fb29092de5ffafa988d59deac">batchVictimsFromStandByList</a> (<a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadInfo)</td></tr>
<tr class="memdesc:a6730003fb29092de5ffafa988d59deac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a batch of victims from the standby list and puts them on the free list.  <br /></td></tr>
<tr class="memitem:a6601998c57f4c3d80891bfcab071441d" id="r_a6601998c57f4c3d80891bfcab071441d"><td class="memItemLeft" align="right" valign="top">PVOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6601998c57f4c3d80891bfcab071441d">getThreadMapping</a> (<a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadContext)</td></tr>
<tr class="memdesc:a6601998c57f4c3d80891bfcab071441d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that gets the current transfer virtual address that a thread needs.  <br /></td></tr>
<tr class="memitem:a9a16d9a9c52782f31f8cbe5ee8fd14e9" id="r_a9a16d9a9c52782f31f8cbe5ee8fd14e9"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a16d9a9c52782f31f8cbe5ee8fd14e9">freeThreadMapping</a> (<a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadContext)</td></tr>
<tr class="memdesc:a9a16d9a9c52782f31f8cbe5ee8fd14e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps the thread's transfer virtual address space if it has all mapped. Batching it in this way saves a lot of time spent mapping and flushing.  <br /></td></tr>
<tr class="memitem:a15daaf165c91aa6784d5c54ea0acef75" id="r_a15daaf165c91aa6784d5c54ea0acef75"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15daaf165c91aa6784d5c54ea0acef75">pageFault</a> (PULONG_PTR arbitrary_va, LPVOID threadContext)</td></tr>
<tr class="memdesc:a15daaf165c91aa6784d5c54ea0acef75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the core of the program. It will culminate in the mapping of a physical page to the passed in virtual address.  <br /></td></tr>
<tr class="memitem:a054a809045b98743dd633e71b528a419" id="r_a054a809045b98743dd633e71b528a419"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a054a809045b98743dd633e71b528a419">isRescue</a> (<a class="el" href="structpte.html">pte</a> *currentPTE)</td></tr>
<tr class="memitem:a77064328a04d35d501edae073abba4e7" id="r_a77064328a04d35d501edae073abba4e7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77064328a04d35d501edae073abba4e7">rescue_page</a> (ULONG64 arbitrary_va, <a class="el" href="structpte.html">pte</a> *currentPTE, <a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadInfo)</td></tr>
<tr class="memdesc:a77064328a04d35d501edae073abba4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will rescue a page table entry that has been unmapped by the trimming thread, but the contents of the virtual page are still on the physical page. If the page corresponding to the virtual address is on the modified list, this function just simply removes it from the middle. If the page is on the standby list, this function removes it from the middle of the list and sets the corresponding disk space free. Lastly, If the page is not on any list, but in the process of being written out, just mark it as no longer being written out. The writer will see this and free the corresponding disk space.  <br /></td></tr>
<tr class="memitem:a09f6bd7a22266dc562f57a1c51d67320" id="r_a09f6bd7a22266dc562f57a1c51d67320"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09f6bd7a22266dc562f57a1c51d67320">mapPage</a> (ULONG64 arbitrary_va, <a class="el" href="structpte.html">pte</a> *currentPTE, LPVOID threadContext, PCRITICAL_SECTION currentPageTableLock)</td></tr>
<tr class="memdesc:a09f6bd7a22266dc562f57a1c51d67320"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles the first time a virtual address is accessed, and if a virtual address contents are on disk. First this thread will attempt to map from the free list; then it will try to map from standby. If none of those succeed it will wake up the trimmer and wait to redo the fault. If this thread notices that usable pages are getting low, it will wake up the trimmer.  <br /></td></tr>
<tr class="memitem:ac535eb59f3846245be236bf3d3855dcc" id="r_ac535eb59f3846245be236bf3d3855dcc"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac535eb59f3846245be236bf3d3855dcc">mapPageFromFreeList</a> (ULONG64 arbitrary_va, <a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadInfo, PULONG64 frameNumber)</td></tr>
<tr class="memdesc:ac535eb59f3846245be236bf3d3855dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tries to get a physical page of a free list. It will also detect if the number of free pages is running low, and take some from the standby list.  <br /></td></tr>
<tr class="memitem:a48c215668a27a6260785ffbbe7cab8c9" id="r_a48c215668a27a6260785ffbbe7cab8c9"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48c215668a27a6260785ffbbe7cab8c9">mapPageFromStandByList</a> (ULONG64 arbitrary_va, <a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadInfo, PULONG64 frameNumber)</td></tr>
<tr class="memdesc:a48c215668a27a6260785ffbbe7cab8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function attempts to take a page from the standby list. If there is a page to take, this function will update the page's pagetable entry to reflect that it is no longer on standby, but on disk.  <br /></td></tr>
<tr class="memitem:adf110e8fee1dab537a5b4a22909843d5" id="r_adf110e8fee1dab537a5b4a22909843d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpfn.html">pfn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf110e8fee1dab537a5b4a22909843d5">getVictimFromStandByList</a> (<a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadInfo)</td></tr>
<tr class="memdesc:adf110e8fee1dab537a5b4a22909843d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pops a page off the standby list and updates its pte. Important note, it updates the page table entry of the page without holding a page table lock. It can do this because the page table entry's corresponding page lock protects it from being rescued at the same. However, this means that in the rescue or other functions relating to standby pages, the page table entry could be changing.  <br /></td></tr>
<tr class="memitem:aa4d5559bed59f8700f4e332ffedd6064" id="r_aa4d5559bed59f8700f4e332ffedd6064"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d5559bed59f8700f4e332ffedd6064">modified_read</a> (<a class="el" href="structpte.html">pte</a> *currentPTE, ULONG64 frameNumber, <a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadContext)</td></tr>
<tr class="memdesc:aa4d5559bed59f8700f4e332ffedd6064"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads in the contents of a disk page onto a physical page. It uses an interim transfer virtual address to complete this task. Only after the entire transfer space is used, will this function unmap the pages from the transfer virtual address. By having limited unmap calls, a lot of time spent flushing and unmapping is saved.  <br /></td></tr>
<tr class="memitem:af2a00908cb7f283fa07f7372f2533d6d" id="r_af2a00908cb7f283fa07f7372f2533d6d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2a00908cb7f283fa07f7372f2533d6d">zeroOnePage</a> (<a class="el" href="structpfn.html">pfn</a> *page, <a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadContext)</td></tr>
<tr class="memdesc:af2a00908cb7f283fa07f7372f2533d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function zeroes a physical page. It uses an interim transfer virtual address to complete this task. Only after the entire transfer space is used, will this function unmap the pages from the transfer virtual address. By having limited unmap calls, a lot of time spent flushing and unmapping is saved.  <br /></td></tr>
<tr class="memitem:aaac03443ad63f63ed80d86cbfcc6bec0" id="r_aaac03443ad63f63ed80d86cbfcc6bec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpfn.html">pfn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaac03443ad63f63ed80d86cbfcc6bec0">getPageFromFreeList</a> (<a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a> threadContext)</td></tr>
<tr class="memdesc:aaac03443ad63f63ed80d86cbfcc6bec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets a page off of one of the free lists. It returns with the page locked.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a448eb2bbcbf9ade5e09d3af9b2bb0ea3" name="a448eb2bbcbf9ade5e09d3af9b2bb0ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448eb2bbcbf9ade5e09d3af9b2bb0ea3">&#9670;&#160;</a></span>addPageToFreeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID addPageToFreeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpfn.html">pfn</a> *</td>          <td class="paramname"><span class="paramname"><em>page</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a page to any available freelist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>The page you are inserting into the list </td></tr>
    <tr><td class="paramname">threadInfo</td><td>The thread info of a caller. It is mainly used for debug functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The page must be locked. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The caller must release the page lock. </dd></dl>

</div>
</div>
<a id="a6730003fb29092de5ffafa988d59deac" name="a6730003fb29092de5ffafa988d59deac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6730003fb29092de5ffafa988d59deac">&#9670;&#160;</a></span>batchVictimsFromStandByList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID batchVictimsFromStandByList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadInfo</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a batch of victims from the standby list and puts them on the free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadInfo</td><td>The thread info of a caller. It is mainly used for debug functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a16d9a9c52782f31f8cbe5ee8fd14e9" name="a9a16d9a9c52782f31f8cbe5ee8fd14e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a16d9a9c52782f31f8cbe5ee8fd14e9">&#9670;&#160;</a></span>freeThreadMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID freeThreadMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadContext</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmaps the thread's transfer virtual address space if it has all mapped. Batching it in this way saves a lot of time spent mapping and flushing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadContext</td><td>The thread info of the caller. It is used to index into the correct transfer virtual address space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaac03443ad63f63ed80d86cbfcc6bec0" name="aaac03443ad63f63ed80d86cbfcc6bec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac03443ad63f63ed80d86cbfcc6bec0">&#9670;&#160;</a></span>getPageFromFreeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpfn.html">pfn</a> * getPageFromFreeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadContext</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets a page off of one of the free lists. It returns with the page locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadContext</td><td>The thread info of the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a free page. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The caller must release the page lock of the returned page. </dd></dl>

</div>
</div>
<a id="a6601998c57f4c3d80891bfcab071441d" name="a6601998c57f4c3d80891bfcab071441d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6601998c57f4c3d80891bfcab071441d">&#9670;&#160;</a></span>getThreadMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PVOID getThreadMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadContext</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that gets the current transfer virtual address that a thread needs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadContext</td><td>The thread info of the caller. It is used to update the per thread index into its transfer virtual address space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a page of unmapped transfer virtual address space. </dd></dl>

</div>
</div>
<a id="adf110e8fee1dab537a5b4a22909843d5" name="adf110e8fee1dab537a5b4a22909843d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf110e8fee1dab537a5b4a22909843d5">&#9670;&#160;</a></span>getVictimFromStandByList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpfn.html">pfn</a> * getVictimFromStandByList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadInfo</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function pops a page off the standby list and updates its pte. Important note, it updates the page table entry of the page without holding a page table lock. It can do this because the page table entry's corresponding page lock protects it from being rescued at the same. However, this means that in the rescue or other functions relating to standby pages, the page table entry could be changing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadInfo</td><td>The thread info of the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a page from the standby list. If the list is empty return NULL </dd></dl>

</div>
</div>
<a id="a054a809045b98743dd633e71b528a419" name="a054a809045b98743dd633e71b528a419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054a809045b98743dd633e71b528a419">&#9670;&#160;</a></span>isRescue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL isRescue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpte.html">pte</a> *</td>          <td class="paramname"><span class="paramname"><em>currentPTE</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentPTE</td><td>The page table entry of the virtual address that was faulted on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>It returns true if the currentPTE is signaled as transition.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The page table entry must be locked. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The caller must release the lock of the page table entry. </dd></dl>

</div>
</div>
<a id="a09f6bd7a22266dc562f57a1c51d67320" name="a09f6bd7a22266dc562f57a1c51d67320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6bd7a22266dc562f57a1c51d67320">&#9670;&#160;</a></span>mapPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL mapPage </td>
          <td>(</td>
          <td class="paramtype">ULONG64</td>          <td class="paramname"><span class="paramname"><em>arbitrary_va</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpte.html">pte</a> *</td>          <td class="paramname"><span class="paramname"><em>currentPTE</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPVOID</td>          <td class="paramname"><span class="paramname"><em>threadContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PCRITICAL_SECTION</td>          <td class="paramname"><span class="paramname"><em>currentPageTableLock</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles the first time a virtual address is accessed, and if a virtual address contents are on disk. First this thread will attempt to map from the free list; then it will try to map from standby. If none of those succeed it will wake up the trimmer and wait to redo the fault. If this thread notices that usable pages are getting low, it will wake up the trimmer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arbitrary_va</td><td>The virtual address being accessed. </td></tr>
    <tr><td class="paramname">currentPTE</td><td>The page table entry of the virtual address being accessed. </td></tr>
    <tr><td class="paramname">threadContext</td><td>The thread info of the faulting thread. </td></tr>
    <tr><td class="paramname">currentPageTableLock</td><td>The lock corresponding to the page table entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if we need to redo the fault, false otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The page table entry must be locked on entry to this function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The caller must unlock the page table entry. </dd></dl>

</div>
</div>
<a id="ac535eb59f3846245be236bf3d3855dcc" name="ac535eb59f3846245be236bf3d3855dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac535eb59f3846245be236bf3d3855dcc">&#9670;&#160;</a></span>mapPageFromFreeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL mapPageFromFreeList </td>
          <td>(</td>
          <td class="paramtype">ULONG64</td>          <td class="paramname"><span class="paramname"><em>arbitrary_va</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PULONG64</td>          <td class="paramname"><span class="paramname"><em>frameNumber</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tries to get a physical page of a free list. It will also detect if the number of free pages is running low, and take some from the standby list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arbitrary_va</td><td>The virtual address that is being faulted. </td></tr>
    <tr><td class="paramname">threadInfo</td><td>The info about the calling thread. </td></tr>
    <tr><td class="paramname">frameNumber</td><td>An address to store the frame number that corresponding to the page we are about to map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if we need to redo the fault, false otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The page table entry must be locked on entry to this function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The caller must unlock the page table entry. </dd></dl>

</div>
</div>
<a id="a48c215668a27a6260785ffbbe7cab8c9" name="a48c215668a27a6260785ffbbe7cab8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c215668a27a6260785ffbbe7cab8c9">&#9670;&#160;</a></span>mapPageFromStandByList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL mapPageFromStandByList </td>
          <td>(</td>
          <td class="paramtype">ULONG64</td>          <td class="paramname"><span class="paramname"><em>arbitrary_va</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PULONG64</td>          <td class="paramname"><span class="paramname"><em>frameNumber</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function attempts to take a page from the standby list. If there is a page to take, this function will update the page's pagetable entry to reflect that it is no longer on standby, but on disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arbitrary_va</td><td>The virtual address that is being faulted on </td></tr>
    <tr><td class="paramname">threadInfo</td><td>The info of the calling thread </td></tr>
    <tr><td class="paramname">frameNumber</td><td>A place to store the frame number of the page that is about to be mapped to the virtual address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if we need to redo the fault, false otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The page table entry must be locked on entry to this function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The caller must unlock the page table entry </dd></dl>

</div>
</div>
<a id="aa4d5559bed59f8700f4e332ffedd6064" name="aa4d5559bed59f8700f4e332ffedd6064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d5559bed59f8700f4e332ffedd6064">&#9670;&#160;</a></span>modified_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID modified_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpte.html">pte</a> *</td>          <td class="paramname"><span class="paramname"><em>currentPTE</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64</td>          <td class="paramname"><span class="paramname"><em>frameNumber</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadContext</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads in the contents of a disk page onto a physical page. It uses an interim transfer virtual address to complete this task. Only after the entire transfer space is used, will this function unmap the pages from the transfer virtual address. By having limited unmap calls, a lot of time spent flushing and unmapping is saved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentPTE</td><td>The page table entry that contains the disk page we want to read from. </td></tr>
    <tr><td class="paramname">frameNumber</td><td>The frame to read into. </td></tr>
    <tr><td class="paramname">threadContext</td><td>The caller's thread info. It is used to determine which transfer virtual page to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The page table entry must be locked on entry to this function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The caller must unlock the page table entry </dd></dl>

</div>
</div>
<a id="a15daaf165c91aa6784d5c54ea0acef75" name="a15daaf165c91aa6784d5c54ea0acef75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15daaf165c91aa6784d5c54ea0acef75">&#9670;&#160;</a></span>pageFault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL pageFault </td>
          <td>(</td>
          <td class="paramtype">PULONG_PTR</td>          <td class="paramname"><span class="paramname"><em>arbitrary_va</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPVOID</td>          <td class="paramname"><span class="paramname"><em>threadContext</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the core of the program. It will culminate in the mapping of a physical page to the passed in virtual address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arbitrary_va</td><td>The virtual address that is being accessed and faulted on. </td></tr>
    <tr><td class="paramname">threadContext</td><td>The information about the faulting thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean that determines whether we need to back up and redo the fault. </dd></dl>

</div>
</div>
<a id="a77064328a04d35d501edae073abba4e7" name="a77064328a04d35d501edae073abba4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77064328a04d35d501edae073abba4e7">&#9670;&#160;</a></span>rescue_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL rescue_page </td>
          <td>(</td>
          <td class="paramtype">ULONG64</td>          <td class="paramname"><span class="paramname"><em>arbitrary_va</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpte.html">pte</a> *</td>          <td class="paramname"><span class="paramname"><em>currentPTE</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will rescue a page table entry that has been unmapped by the trimming thread, but the contents of the virtual page are still on the physical page. If the page corresponding to the virtual address is on the modified list, this function just simply removes it from the middle. If the page is on the standby list, this function removes it from the middle of the list and sets the corresponding disk space free. Lastly, If the page is not on any list, but in the process of being written out, just mark it as no longer being written out. The writer will see this and free the corresponding disk space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arbitrary_va</td><td>The virtual address that is faulted on. </td></tr>
    <tr><td class="paramname">currentPTE</td><td>The page table entry corresponding with the virtual address. </td></tr>
    <tr><td class="paramname">threadInfo</td><td>The info of the thread that is faulted on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if we need to redo the fault, false otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The page table entry must be locked on entry to this function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The caller must unlock the page table entry </dd></dl>

</div>
</div>
<a id="ad208b74b4a578d8eb271b1d9ed34d5c2" name="ad208b74b4a578d8eb271b1d9ed34d5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad208b74b4a578d8eb271b1d9ed34d5c2">&#9670;&#160;</a></span>spinWhileWaiting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID spinWhileWaiting </td>
          <td>(</td>
          <td class="paramtype">VOID</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function spins while waiting so waits show up as time on a performance trace. </p>
<ul>
<li></li>
</ul>

</div>
</div>
<a id="af2a00908cb7f283fa07f7372f2533d6d" name="af2a00908cb7f283fa07f7372f2533d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a00908cb7f283fa07f7372f2533d6d">&#9670;&#160;</a></span>zeroOnePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL zeroOnePage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpfn.html">pfn</a> *</td>          <td class="paramname"><span class="paramname"><em>page</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structures_8h.html#a0d2bf865b114b5aa46dd6f5558f60df4">PTHREAD_INFO</a></td>          <td class="paramname"><span class="paramname"><em>threadContext</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function zeroes a physical page. It uses an interim transfer virtual address to complete this task. Only after the entire transfer space is used, will this function unmap the pages from the transfer virtual address. By having limited unmap calls, a lot of time spent flushing and unmapping is saved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>The page to zero. </td></tr>
    <tr><td class="paramname">threadContext</td><td>The caller's thread info. It is used to determine which transfer virtual page to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="dir_3454632d1a606e9a309cdaae2c26d5ae.html">threads</a></li><li class="navelem"><a href="user__thread_8c.html">user_thread.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
